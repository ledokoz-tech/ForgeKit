//! Documentation generation module
//!
//! This module provides functionality for generating project documentation.

use crate::error::ForgeKitError;
use std::path::Path;

/// Documentation configuration
#[derive(Debug, Clone)]
pub struct DocConfig {
    pub output_dir: String,
    pub include_examples: bool,
    pub include_api_reference: bool,
}

impl Default for DocConfig {
    fn default() -> Self {
        Self {
            output_dir: "./docs".to_string(),
            include_examples: true,
            include_api_reference: true,
        }
    }
}

/// Documentation generator
pub struct DocGenerator {
    config: DocConfig,
}

impl DocGenerator {
    /// Create a new documentation generator
    pub fn new(config: DocConfig) -> Self {
        Self { config }
    }

    /// Generate documentation
    pub async fn generate_docs(path: &Path) -> Result<std::path::PathBuf, ForgeKitError> {
        let config = DocConfig::default();
        let generator = Self::new(config);
        generator.generate(path).await
    }

    /// Generate API reference
    pub async fn generate_api_reference(path: &Path) -> Result<String, ForgeKitError> {
        let src_path = path.join("src");
        if !src_path.exists() {
            return Ok("No API reference available".to_string());
        }

        let mut reference = String::from("# API Reference\n\n");
        reference.push_str("## Modules\n\n");

        for entry in walkdir::WalkDir::new(&src_path)
            .into_iter()
            .filter_map(|e| e.ok())
        {
            if entry.path().extension().map(|e| e == "rs").unwrap_or(false) {
                if let Some(filename) = entry.file_name().to_str() {
                    reference.push_str(&format!("- {}\n", filename));
                }
            }
        }

        Ok(reference)
    }

    async fn generate(&self, path: &Path) -> Result<std::path::PathBuf, ForgeKitError> {
        let output_path = path.join(&self.config.output_dir);
        std::fs::create_dir_all(&output_path)?;

        let index_path = output_path.join("index.html");
        let html = r#"<!DOCTYPE html>
<html>
<head>
    <title>Project Documentation</title>
</head>
<body>
    <h1>Project Documentation</h1>
    <p>Documentation generated by ForgeKit</p>
</body>
</html>"#;

        std::fs::write(&index_path, html)?;
        Ok(output_path)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_doc_config() {
        let config = DocConfig::default();
        assert_eq!(config.output_dir, "./docs");
        assert!(config.include_examples);
    }

    #[test]
    fn test_doc_generator_creation() {
        let config = DocConfig::default();
        let _generator = DocGenerator::new(config);
    }
}
